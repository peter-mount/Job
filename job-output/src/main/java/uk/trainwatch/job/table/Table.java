/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.trainwatch.job.table;

import java.text.Format;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * A table generated by a script
 * <p>
 * @author peter
 */
public class Table
        extends Molecule<Row>
{

    private final Molecule<Header> headers = new Molecule<Header>()
    {

        @Override
        public void accept( TableVisitor t )
        {
        }

    };
    private Header lastHeader;
    private Row lastRow;

    private List<TableStringFormat> formats;

    public Table()
    {
    }

    public Table( Object obj )
    {
        append( obj );
    }

    public Table append( Object obj )
    {
        if( obj instanceof Map ) {
            return appendMap( (Map<String, Object>) obj );
        }
        if( obj instanceof Iterable ) {
            return appendIterable( (Iterable) obj );
        }
        if( obj instanceof Iterator ) {
            return appendIterable( (Iterable) obj );
        }

        Class c = obj.getClass();
        if( c.isArray() ) {
            if( c.getComponentType().isPrimitive() ) {
                throw new UnsupportedOperationException( "Appending primitive arrays are unsupported" );
            }
            return appendArray( (Object[]) obj );
        }

        throw new IllegalArgumentException( "Unsupported object " + obj );
    }

    private <T> Table appendArray( T[] a )
    {
        for( T e: a ) {
            append( e );
        }
        return this;
    }

    private Table appendIterable( Iterable iterable )
    {
        return appendIterator( iterable.iterator() );
    }

    private Table appendIterator( Iterator it )
    {
        while( it.hasNext() ) {
            append( it.next() );
        }
        return this;
    }

    private Table appendMap( Map<String, Object> m )
    {
        if( lastHeader == null ) {
            newHeader();
        }
        Row r = newRow();
        m.forEach( ( k, v ) -> {
            if( !lastHeader.contains( k ) ) {
                lastHeader.newCell( k );
            }
            r.set( lastHeader.indexOf( k ), v );
        } );

        return this;
    }

    public List<TableStringFormat> getFormats()
    {
        return formats == null ? new ArrayList<>() : new ArrayList<>( formats );
    }

    public <T extends Format> T getFormat( int col )
    {
        return formats == null || formats.size() < col ? null : (T) formats.get( col );
    }

    public Table setFormat( int col, TableStringFormat f )
    {
        if( formats == null ) {
            formats = new ArrayList<>();
        }
        while( formats.size() < col ) {
            formats.add( null );
        }
        formats.add( col, f );
        return this;
    }

    public int getHeaderCount()
    {
        return headers.size();
    }

    public boolean isHeadersEmpty()
    {
        return headers.isEmpty();
    }

    public Header newHeader()
    {
        lastHeader = new Header();
        headers.getElements().add( lastHeader );
        return lastHeader;
    }

    public void forEachHeader( Consumer<Header> c )
    {
        headers.forEach( c );
    }

    public Row newRow()
    {
        Row row = new Row();
        getElements().add( row );
        return row;
    }

    public Row newRow( Object... args )
    {
        lastRow = newRow();
        if( args != null && args.length > 0 ) {
            for( Object arg: args ) {
                lastRow.append( arg );
            }
        }
        return lastRow;
    }

    @Override
    public void accept( TableVisitor t )
    {
        t.visit( this );
    }

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        accept( new StringTableVisitor( sb, FormatTableVisitor.getFormatters( this ) ) );

        return sb.toString();
    }

}
