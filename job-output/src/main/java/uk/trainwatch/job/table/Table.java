/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.trainwatch.job.table;

import uk.trainwatch.job.table.visitors.CSVTableVisitor;
import java.io.IOException;
import java.io.StringWriter;
import java.io.UncheckedIOException;
import uk.trainwatch.job.table.visitors.FormatTableVisitor;
import uk.trainwatch.job.table.visitors.StringTableVisitor;
import uk.trainwatch.job.table.visitors.TableVisitor;
import java.text.Format;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import org.apache.commons.csv.CSVFormat;
import uk.trainwatch.job.table.visitors.XHTMLTableVisitor;

/**
 * A table generated by a script
 * <p>
 * @author peter
 */
public class Table
        extends Molecule<Row>
{

    private final Headers headers = new Headers();
    private Header lastHeader;
    private Row lastRow;

    private List<TableStringFormat> formats;

    public Table()
    {
    }

    public Table( Object obj )
    {
        append( obj );
    }

    public Table append( Object obj )
    {
        if( obj instanceof Map ) {
            return appendMap( (Map<String, Object>) obj );
        }
        if( obj instanceof Iterable ) {
            return appendIterable( (Iterable) obj );
        }
        if( obj instanceof Iterator ) {
            return appendIterable( (Iterable) obj );
        }

        Class c = obj.getClass();
        if( c.isArray() ) {
            if( c.getComponentType().isPrimitive() ) {
                throw new UnsupportedOperationException( "Appending primitive arrays are unsupported" );
            }
            return appendArray( (Object[]) obj );
        }

        throw new IllegalArgumentException( "Unsupported object " + obj );
    }

    private <T> Table appendArray( T[] a )
    {
        for( T e: a ) {
            append( e );
        }
        return this;
    }

    private Table appendIterable( Iterable iterable )
    {
        return appendIterator( iterable.iterator() );
    }

    private Table appendIterator( Iterator it )
    {
        while( it.hasNext() ) {
            append( it.next() );
        }
        return this;
    }

    private Table appendMap( Map<String, Object> m )
    {
        if( lastHeader == null ) {
            newHeader();
        }
        Row r = newRow();
        m.forEach( ( k, v ) -> {
            if( !lastHeader.contains( k ) ) {
                lastHeader.newCell( k );
            }
            r.set( lastHeader.indexOf( k ), v );
        } );

        return this;
    }

    public List<TableStringFormat> getFormats()
    {
        return formats == null ? new ArrayList<>() : new ArrayList<>( formats );
    }

    public <T extends Format> T getFormat( int col )
    {
        return formats == null || formats.size() < col ? null : (T) formats.get( col );
    }

    public Table setFormat( int col, TableStringFormat f )
    {
        if( formats == null ) {
            formats = new ArrayList<>();
        }
        while( formats.size() < col ) {
            formats.add( null );
        }
        formats.add( col, f );
        return this;
    }

    public int getHeaderCount()
    {
        return headers.size();
    }

    public boolean isHeadersEmpty()
    {
        return headers.isEmpty();
    }

    public Header newHeader()
    {
        lastHeader = new Header();
        headers.add( lastHeader );
        return lastHeader;
    }

    public void forEachHeader( Consumer<Header> c )
    {
        headers.forEach( c );
    }

    public void removeColumn( String name )
    {
        if( lastHeader != null ) {
            int col = lastHeader.indexOf( name );
            if( col > -1 ) {
                headers.forEach( h -> h.removeColumn( col ) );
                forEach( r -> r.removeColumn( col ) );
            }
        }
    }

    public Row newRow()
    {
        Row row = new Row();
        getElements().add( row );
        return row;
    }

    public Row newRow( Object... args )
    {
        lastRow = newRow();
        if( args != null && args.length > 0 ) {
            for( Object arg: args ) {
                lastRow.append( arg );
            }
        }
        return lastRow;
    }

    @Override
    public void accept( TableVisitor t )
    {
        t.visit( this );
    }

    private String toString( Function<Appendable, TableVisitor> f )
    {
        try( StringWriter sw = new StringWriter() ) {
            accept( f.apply( sw ) );
            return sw.toString();
        }
        catch( IOException ex ) {
            throw new UncheckedIOException( ex );
        }
    }

    /**
     * Return's this table in a string format
     * <p>
     * @return
     */
    @Override
    public String toString()
    {
        return toString( a -> new StringTableVisitor( a, FormatTableVisitor.getFormatters( this ) ) );
    }

    /**
     * Return this table in html
     * <p>
     * @return
     *         <p>
     * @throws IOException
     */
    public String toHTML()
            throws IOException
    {
        return toString( a -> new XHTMLTableVisitor( a, FormatTableVisitor.getFormatters( this ) ) );
    }

    /**
     * Return this table as csv
     * <p>
     * @return
     */
    public String toCSV()
    {
        return toString( a -> new CSVTableVisitor( a ) );
    }

    /**
     * Return this table as Excel compatible CSV
     * <p>
     * @return
     */
    public String toExcel()
    {
        return toString( a -> new CSVTableVisitor( a, CSVFormat.RFC4180 ) );
    }

    /**
     * Return this table as RFC 4180 compatible CSV
     * <p>
     * @return
     */
    public String toRFC4180()
    {
        return toString( a -> new CSVTableVisitor( a, CSVFormat.RFC4180 ) );
    }

    /**
     * Return this table in Tab Delimited Format
     * <p>
     * @return
     */
    public String toTDF()
    {
        return toString( a -> new CSVTableVisitor( a, CSVFormat.TDF ) );
    }
}
